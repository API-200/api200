
create function update_updated_at_column() returns trigger
    language plpgsql
as
$$
BEGIN
    NEW.updated_at
= NOW();
RETURN NEW;
END;
$$;

alter function update_updated_at_column() owner to postgres;

grant execute on function update_updated_at_column() to anon;

grant execute on function update_updated_at_column() to authenticated;

grant execute on function update_updated_at_column() to service_role;

create table api_keys
(
    user_id    uuid not null
        references auth.users,
    key        text not null
        unique,
    created_at timestamp with time zone default now(),
    id         bigint generated by default as identity
        primary key
        unique
);

alter table api_keys
    owner to postgres;

create index idx_api_keys_key
    on api_keys (key);

grant delete, insert, references, select, trigger, truncate, update on api_keys to anon;

grant delete, insert, references, select, trigger, truncate, update on api_keys to authenticated;

grant delete, insert, references, select, trigger, truncate, update on api_keys to service_role;

create table services
(
    name         text                                        not null,
    description  text,
    base_url     text                                        not null,
    created_at   timestamp with time zone default now(),
    updated_at   timestamp with time zone default now(),
    user_id      uuid                     default auth.uid() not null
        references auth.users,
    auth_type    varchar(10)
        constraint services_auth_type_check
            check ((auth_type)::text = ANY
                   (ARRAY [('api_key'::character varying)::text, ('token'::character varying)::text])),
    auth_enabled boolean                  default false      not null,
    auth_config  jsonb,
    id           bigint generated by default as identity
        primary key
        unique,
    source       text
);

alter table services
    owner to postgres;

create index idx_services_name
    on services (name);

create trigger services_updated_at
    before update
    on services
    for each row
execute procedure update_updated_at_column();

grant delete, insert, references, select, trigger, truncate, update on services to anon;

grant delete, insert, references, select, trigger, truncate, update on services to authenticated;

grant delete, insert, references, select, trigger, truncate, update on services to service_role;

create table endpoints
(
    name                      text                                           not null,
    method                    text                                           not null,
    full_url                  text                                           not null,
    created_at                timestamp with time zone default now(),
    updated_at                timestamp with time zone default now(),
    cache_enabled             boolean                  default false         not null,
    cache_ttl_s               integer
        constraint endpoints_cache_ttl_s_check
            check (cache_ttl_s <= 86400),
    id                        bigint generated by default as identity
        primary key
        unique,
    data_mapping_enabled      boolean                  default false         not null,
    data_mapping_function     text
        constraint endpoints_data_mapping_function_check
            check (length(data_mapping_function) <= 1000000),
    service_id                bigint                                         not null
        references services
            on update cascade on delete cascade,
    retry_count               smallint                 default '0'::smallint not null
        constraint endpoints_retry_count_check
            check (retry_count <= 5),
    retry_interval_s          smallint                 default '0'::smallint not null
        constraint endpoints_retry_interval_s_check
            check (retry_interval_s <= 60),
    mock_enabled              boolean                  default false         not null,
    mock_status_code          smallint,
    mock_response             jsonb
        constraint endpoints_mock_response_check
            check (pg_column_size(mock_response) <= 1000000),
    fallback_response_enabled boolean                  default false         not null,
    fallback_status_code      smallint,
    fallback_response         jsonb
        constraint endpoints_fallback_response_check
            check (pg_column_size(fallback_response) <= 1000),
    retry_enabled             boolean                  default false         not null,
    regex_path                text,
    source                    text,
    schema                    jsonb,
    description               text
);

alter table endpoints
    owner to postgres;

create index idx_endpoints_name
    on endpoints (name);

create trigger endpoints_updated_at
    before update
    on endpoints
    for each row
execute procedure update_updated_at_column();

grant delete, insert, references, select, trigger, truncate, update on endpoints to anon;

grant delete, insert, references, select, trigger, truncate, update on endpoints to authenticated;

grant delete, insert, references, select, trigger, truncate, update on endpoints to service_role;

create table logs
(
    id                   bigint generated by default as identity
        primary key,
    req_body             json,
    req_headers          json    default '{}'::json not null,
    res_body             json,
    res_headers          json,
    res_code             smallint,
    error                json,
    started_at           timestamp with time zone   not null,
    finished_at          timestamp with time zone   not null,
    took_ms              bigint,
    cache_hit            boolean default false      not null,
    retry_number         smallint,
    correlation_id       uuid                       not null,
    endpoint_id          bigint                     not null
        references endpoints
            on update cascade on delete cascade,
    ip                   text    default ''::text   not null,
    is_mock_response     boolean default false      not null,
    is_fallback_response boolean default false      not null,
    req_url              text                       not null
);

alter table logs
    owner to postgres;

grant delete, insert, references, select, trigger, truncate, update on logs to anon;

grant delete, insert, references, select, trigger, truncate, update on logs to authenticated;

grant delete, insert, references, select, trigger, truncate, update on logs to service_role;

create table usages
(
    id                 bigint generated by default as identity
        primary key,
    user_id            uuid                                   not null
        references auth.users
            on update cascade on delete cascade,
    calls_count        integer                  default 1     not null,
    billing_started_at timestamp with time zone default now() not null
);

alter table usages
    owner to postgres;



grant delete, insert, references, select, trigger, truncate, update on usages to anon;

grant delete, insert, references, select, trigger, truncate, update on usages to authenticated;

grant delete, insert, references, select, trigger, truncate, update on usages to service_role;

grant select, update, usage on sequence endpoints_id_seq to anon;

grant select, update, usage on sequence endpoints_id_seq to authenticated;

grant select, update, usage on sequence endpoints_id_seq to service_role;

grant select, update, usage on sequence logs_id_seq to anon;

grant select, update, usage on sequence logs_id_seq to authenticated;

grant select, update, usage on sequence logs_id_seq to service_role;

grant select, update, usage on sequence services_id_seq to anon;

grant select, update, usage on sequence services_id_seq to authenticated;

grant select, update, usage on sequence services_id_seq to service_role;

grant select, update, usage on sequence usages_id_seq to anon;

grant select, update, usage on sequence usages_id_seq to authenticated;

grant select, update, usage on sequence usages_id_seq to service_role;

create policy "Delete for Auth Users" on services
    as permissive
    for delete
    to authenticated
    using (user_id = auth.uid());

create policy "Delete for Auth Users" on endpoints
    as permissive
    for delete
    to authenticated
    using (service_id IN (SELECT services.id
                          FROM services
                          WHERE (services.user_id = auth.uid())));

create policy "Delete for Auth Users" on api_keys
    as permissive
    for delete
    to authenticated
    using (user_id = auth.uid());

create policy "Insert for Auth Users" on services
    as permissive
    for insert
    to authenticated
    with check (user_id = auth.uid());

create policy "Insert for Auth Users" on endpoints
    as permissive
    for insert
    to authenticated
    with check (service_id IN (SELECT services.id
                               FROM services
                               WHERE (services.user_id = auth.uid())));

create policy "Insert for Auth Users" on api_keys
    as permissive
    for insert
    to authenticated
    with check (user_id = auth.uid());

create policy "Select for Auth Users" on services
    as permissive
    for select
    to authenticated
    using (user_id = auth.uid());

create policy "Select for Auth Users" on endpoints
    as permissive
    for select
    to authenticated
    using (service_id IN (SELECT services.id
                          FROM services
                          WHERE (services.user_id = auth.uid())));

create policy "Select for Auth Users" on api_keys
    as permissive
    for select
    to authenticated
    using (user_id = auth.uid());

create policy "Select for Auth Users" on logs
    as permissive
    for select
    to authenticated
    using (EXISTS (SELECT 1
                   FROM (endpoints e
                       JOIN services s ON ((e.service_id = s.id)))
                   WHERE ((e.id = logs.endpoint_id) AND (s.user_id = auth.uid()))));

create policy "Select for Auth Users" on usages
    as permissive
    for select
    to authenticated
    using (user_id = auth.uid());

create policy "Update for Auth Users" on services
    as permissive
    for update
    to authenticated
    using (user_id = auth.uid())
    with check (user_id = auth.uid());

create policy "Update for Auth Users" on endpoints
    as permissive
    for update
    to authenticated
    using (service_id IN (SELECT services.id
                          FROM services
                          WHERE (services.user_id = auth.uid())))
    with check (service_id IN (SELECT services.id
                               FROM services
                               WHERE (services.user_id = auth.uid())));

create policy "Update for Auth Users" on api_keys
    as permissive
    for update
    to authenticated
    using (user_id = auth.uid())
    with check (user_id = auth.uid());

create function get_route_data(p_service_name text, p_user_id uuid, p_endpoint_name text) returns json
    security definer
    language plpgsql
as
$$DECLARE
    result json;
BEGIN
    SELECT 
        json_build_object(
            'id', s.id,
            'name', s.name,
            'description', s.description,
            'base_url', s.base_url,
            'user_id', s.user_id,
            'created_at', s.created_at,
            'updated_at', s.updated_at,
            'auth_type', s.auth_type,
            'auth_enabled', s.auth_enabled,
            'auth_config', s.auth_config,
            'endpoints', json_agg(
                json_build_object(
                    'id', e.id,
                    'name', e.name,
                    'method', e.method,
                    'full_url', e.full_url,
                    'regex_path', e.regex_path,
                    'created_at', e.created_at,
                    'updated_at', e.updated_at,
                    'cache_enabled', e.cache_enabled,
                    'cache_ttl_s', e.cache_ttl_s,
                    'data_mapping_enabled', e.data_mapping_enabled,
                    'data_mapping_function', e.data_mapping_function,
                    'service_id', e.service_id,
                    'retry_count', e.retry_count,
                    'retry_interval_s', e.retry_interval_s,
                    'mock_enabled', e.mock_enabled,
                    'mock_status_code', e.mock_status_code,
                    'mock_response', e.mock_response,
                    'fallback_response_enabled', e.fallback_response_enabled,
                    'fallback_status_code', e.fallback_status_code,
                    'fallback_response', e.fallback_response,
                    'retry_enabled', e.retry_enabled
                )
            )
        ) INTO result
    FROM services s
    INNER JOIN endpoints e ON e.service_id = s.id
    WHERE s.name = p_service_name
      AND s.user_id = p_user_id
      AND p_endpoint_name ~ e.regex_path
    GROUP BY s.id;

    RETURN result;
END;$$;

alter function get_route_data(text, uuid, text) owner to postgres;

grant execute on function get_route_data(text, uuid, text) to anon;

grant execute on function get_route_data(text, uuid, text) to authenticated;

grant execute on function get_route_data(text, uuid, text) to service_role;

create function increment_usage(p_user_id uuid, p_max_requests integer)
    returns TABLE(allowed boolean, c_count integer)
    language plpgsql
as
$$
DECLARE
    v_calls_count integer;
BEGIN
    -- Update with explicit table reference
    -- Update with explicit table reference
    UPDATE usages
    SET calls_count = calls_count + 1
    WHERE user_id = p_user_id 
      AND calls_count < p_max_requests
    RETURNING calls_count INTO v_calls_count;

    IF FOUND THEN
        allowed := true;
        c_count := v_calls_count;
        RETURN NEXT;
        RETURN;
    END IF;

    -- Explicit table reference in SELECT
    SELECT calls_count INTO v_calls_count
    FROM usages
    WHERE user_id = p_user_id;

    IF FOUND THEN
        allowed := false;
        c_count := v_calls_count;
        RETURN NEXT;
        RETURN;
    END IF;

    -- Insert new record with table alias in RETURNING clause
    INSERT INTO usages (user_id, calls_count)
    VALUES (p_user_id, 1)
    RETURNING calls_count INTO v_calls_count;

    allowed := true;
    c_count := v_calls_count;
    RETURN NEXT;
END;
$$;

alter function increment_usage(uuid, integer) owner to postgres;

grant execute on function increment_usage(uuid, integer) to anon;

grant execute on function increment_usage(uuid, integer) to authenticated;

grant execute on function increment_usage(uuid, integer) to service_role;


